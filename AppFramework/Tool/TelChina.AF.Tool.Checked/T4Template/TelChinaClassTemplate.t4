<#@ Include File="TelChinaTemplateHeader.t4" #>
<#@ Modeling ElementType="Microsoft.VisualStudio.Uml.Classes.IClass" Processor="ModelingProcessor" ApplyStereotypes="CSharp" #>
<#@ Assembly Name="Microsoft.VisualStudio.ArchitectureTools.Extensibility, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL" #>
<#@ Import Namespace="Microsoft.VisualStudio.Uml.AuxiliaryConstructs" #>
<#@ Import Namespace="Microsoft.VisualStudio.Uml.Classes" #>
<#@ Import Namespace="Microsoft.VisualStudio.ArchitectureTools.Extensibility.Uml" #>
<#@ Import Namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ Include File="TelChinaCSharpCommentHelpers.t4" #>
<#@ Include File="TelChinaCSharpHelpers.t4" #>
<#@ Output Extension=".cs" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
<# 
	//System.Diagnostics.Debugger.Launch(); 
    //using集合
	WriteUsingStatements(this.Element,"EntityBase");
    WriteLine("");
	string classNamespace =this.Element.Namespace.ToString();
	classNamespace=GetNamespace(this.Element.Namespace);
    if(!string.IsNullOrEmpty(classNamespace))
    {
#>
namespace <#= classNamespace #>
{
<#   
		 PushIndent("\t");
    }	
	//类的注释
	WriteSummaryComment(this.Element.Description);    
	WriteTemplateTypeParameterComments(TemplateParameterNameDescriptionPairs(this.Element));
    foreach(var comment in this.Element.GetModelStore().AllInstances<IComment>().Where(c => c.AnnotatedElements.Contains(this.Element)))
    {
        WriteRemarksComment(comment.Body);
    }
#>
<#
	//特性类
    WriteClassClrAttributes(this.Element);
	//WriteTelChinaClassClrAttributes(this.Element);
#>
<#= ClassVisibility(this.Element) #><#= ClassUnsafeOption(this.Element) #><#= ClassStaticOption(this.Element) #><#= ClassAbstractOption(this.Element) #><#= ClassSealedOption(this.Element) #><#= ClassPartialOption(this.Element) #>class <#= ClassifierName(this.Element) #><#= ImplementedAndInheritedList(this.Element) #>
{
<#
    PushIndent("\t");

    // Write Attributes
    var ownedAttributes = this.Element.OwnedAttributes;
	//私有属性
	string IsGenerationAttribute = GetTelChinaProperty(this.Element, "EntityBase", "IsGenerationAttribute");
	bool isGenerationSmall =false;
	if(string.IsNullOrEmpty(IsGenerationAttribute)||IsGenerationAttribute=="true")
	{
		isGenerationSmall = true;
		foreach(IProperty attribute in ownedAttributes)
	    {
	        WriteSummaryComment(attribute.Description);
	        WritePrivatePropertyForTelChina(attribute);
	        WriteLine("");
	    }
	}
    foreach(IProperty attribute in ownedAttributes)
    {
        WriteSummaryComment(attribute.Description);
		//属性扩展
		WritePropertyMetaDataAttribute(attribute);
        WriteClassUmlPropertyDefinition(attribute,isGenerationSmall);	
        WriteLine("");
    }
	//增加属性EntityComponent
	if(this.Element.Name!="PropertyMetaDataAttribute")
	{
		WritePropertyForTelchinaPeculiar();
	}
	
#>

<#	
	
    // Write 关联关系Associations    
	foreach(IDependency dependency in this.Element.GetRelatedLinks<IDependency>()) 
	{
		if(dependency.Client ==this.Element)
		{
			WriteDependencyPropertyForTelChina(dependency,isGenerationSmall);
		}
	}	
	// Write 组合，聚合关系Associations    
	foreach(IAssociation association in this.Element.GetRelatedLinks<IAssociation>()) 
	{
		IEnumerable<IProperty> navigableEnds = association.MemberEnds;//association.NavigableOwnedEnds;
		foreach (IProperty ownedEnd in navigableEnds)
		{
			if ((!StringComparer.OrdinalIgnoreCase.Equals(ownedEnd.Type.QualifiedName, this.Element.QualifiedName)
				||association.SourceElement == association.TargetElement)
				&&!IsMemberEndProcessedAsAttribute(ownedEnd, ownedAttributes))
			{				
				if(ownedEnd.Opposite.Aggregation ==Microsoft.VisualStudio.Uml.Classes.AggregationKind.None)
				{
					//生成关联实体
					WriteAssociationPropertyForTelChina(ownedEnd,isGenerationSmall,ownedEnd.Type.Description);
				}
				else
				{
					//生成集合
					WriteCollectionPropertyForTelChina(ownedEnd,isGenerationSmall,ownedEnd.Type.Description);					
				}
			}
		}	
		
	}	
	//构造函数
	/*
	string classConstructor =string.Empty;
	
	foreach(IAssociation association in this.Element.GetRelatedLinks<IAssociation>()) 
	{
		IEnumerable<IProperty> navigableEnds = association.MemberEnds;//association.NavigableOwnedEnds;
		foreach (IProperty ownedEnd in navigableEnds)
		{
			if ((!StringComparer.OrdinalIgnoreCase.Equals(ownedEnd.Type.QualifiedName, this.Element.QualifiedName)
				||association.SourceElement == association.TargetElement)
				&&!IsMemberEndProcessedAsAttribute(ownedEnd, ownedAttributes))
			{				
				if(ownedEnd.Opposite.Aggregation !=Microsoft.VisualStudio.Uml.Classes.AggregationKind.None)
				{
					//生成集合
					string fildName = ownedEnd.Name + "s";
					string _smallfildName = FieldnameToSmall(fildName);	
					if(string.IsNullOrEmpty(classConstructor))
					{
						WriteSummaryComment("构造函数");
						WriteLine("public " + ClassifierName(this.Element) +"()");
				        WriteLine("{");
				        PushIndent("\t");
						classConstructor =" this."+ _smallfildName +".ItemChanged += this.OnSetItemChanged;";
						WriteLine(classConstructor);
					}
					else
					{						
						classConstructor =" this."+ _smallfildName +".ItemChanged += this.OnSetItemChanged;";
						WriteLine(classConstructor);
					}
				}
			}
		}	
		
	}
	if(!string.IsNullOrEmpty(classConstructor))
	{		
		PopIndent();        
		WriteLine("}");
	}
	*/
	PopIndent();
#>
}
<#
    ClearIndent();
    if(!string.IsNullOrEmpty(classNamespace))
    {
#>
}
<#  } #>


<#+   
	#region Inheritance

    /// <summary>
    /// Gets the implemented and inherited types of the given class.
    /// </summary>
    /// <param name="aClass">The given class</param>
    /// <returns>implementedAndInherted types</returns>
    private static string ImplementedAndInheritedList(IClass aClass)
    {
        var list = ImplementedAndInheritedTypes(aClass);
        if(list.Any())
        {
            return " : " + string.Join(", ", list.Select(t => ElementClassType(t)));
        }
        else
        {
			if(aClass.Name =="PropertyMetaDataAttribute")
			{
				return " : Attribute";
			}
            return " : EntityBase";
        }
    }	
    #endregion Inheritance
	
	 #region Polymorphism

    /// <summary>
    /// Gets the overload option of the indexer.
    /// </summary>
    /// <param name="operation">The operation</param>
    /// <param name="owner">The class</param>
    /// <returns>The overload option for the operation</returns>
    private static string ClassIndexerOverloadOption(IOperation operation, IClass owner)
    {
        return ClassOperationOverloadOption(operation, owner);
    }

    /// <summary>
    /// Gets the overload option of the method.
    /// </summary>
    /// <param name="operation">The operation</param>
    /// <param name="owner">The class</param>
    /// <returns>The overload option for the operation</returns>
    private static string ClassMethodOverloadOption(IOperation operation, IClass owner)
    {
        if(string.IsNullOrEmpty(MethodPartialOption(operation)))
        {
            return ClassOperationOverloadOption(operation, owner);
        }
        else 
        {
            return string.Empty;
        }
    }

    /// <summary>
    /// Gets the overload option of the operation.
    /// </summary>
    /// <param name="operation">The operation</param>
    /// <param name="owner">The class</param>
    /// <returns>The overload option for the operation</returns>
    private static string ClassOperationOverloadOption(IOperation operation, IClass owner)
    {
        string overload = string.Empty;
        if(!string.IsNullOrEmpty(OperationAbstractOption(operation)))
        {
            overload += "abstract ";
        }
        else if(IsInheritedMember(operation, owner))
        {
            overload += "override ";
            if(!string.IsNullOrEmpty(OperationSealedOption(operation)))
            {
                overload += "sealed ";
            }
        }
        else if(IsOverridable(operation, owner))
        {
            overload += "virtual ";
        }
		
        return overload;
    }

    /// <summary>
    /// Gets the overload option of the property.
    /// </summary>
    /// <param name="property">The property</param>
    /// <param name="owner">The class</param>
    /// <returns>The overload option for the property</returns>
    private static string ClassPropertyOverloadOption(IProperty property, IClass owner)
    {
        string overload = string.Empty;
        if(IsInheritedMember(property, owner))
        {
            overload = "override ";
            if(!string.IsNullOrEmpty(PropertySealedOption(property)))
            {
                overload += "sealed ";
            }
        }
        else if(IsOverridable(property, owner))
        {
            overload += "virtual ";
        }
        return overload;
    }

    /// <summary>
    /// Checks if the operation is overridable.
    /// </summary>
    /// <param name="operation">The operation</param>
    /// <param name="owner">The class</param>
    /// <returns>true if the operation is an inherited member.</returns>
    private static bool IsOverridable(IOperation operation, IClass owner)
    {
        bool isPrivate = MethodVisibility(operation) == "private " || IndexerVisibility(operation) == "private ";
        return !isPrivate && string.IsNullOrEmpty(OperationStaticOption(operation)) && string.IsNullOrEmpty(OperationSealedOption(operation)) && HasVirtualMembers(owner);
    }

    /// <summary>
    /// Checks if the property is overridable.
    /// </summary>
    /// <param name="property">The property</param>
    /// <param name="owner">The class</param>
    /// <returns>true if the property is an inherited member.</returns>
    private static bool IsOverridable(IProperty property, IClass owner)
    {
        bool isPrivate = FieldVisibility(property) == "private " || PropertyVisibility(property) == "private ";
        return !isPrivate && string.IsNullOrEmpty(AttributeStaticOption(property)) && string.IsNullOrEmpty(PropertySealedOption(property)) && HasVirtualMembers(owner);
    }

    /// <summary>
    /// Checks if the classifier could have virtual memebers.
    /// </summary>
    /// <param name="aClass">The class</param>
    /// <returns>true if the property is an inherited member.</returns>
    private static bool HasVirtualMembers(IClass aClass)
    {
        return string.IsNullOrEmpty(ClassSealedOption(aClass)) && string.IsNullOrEmpty(ClassStaticOption(aClass));
    }

    /// <summary>
    /// Checks if the property is an inherited member.
    /// </summary>
    /// <param name="property">The property</param>
    /// <param name="owner">The owner class of the property</param>
    /// <returns>true if the property is an inherited member.</returns>
    private static bool IsInheritedMember(IProperty property, IClass owner)
    {
        var types = ImplementedOrInheritedTypes(owner);
        foreach(IType type in types) 
        {
            IClassifier baseClassifier = type as IClassifier;
            if(baseClassifier != null) 
            {
                ITemplateBinding templateBinding = GetTemplateBinding(baseClassifier);
                IClassifier bindingClassifier = GetBindingClassifier(templateBinding);
                if(bindingClassifier != null)
                {
                    baseClassifier = bindingClassifier;
                }

                foreach(IProperty propertyInBase in GetOwnedProperties(baseClassifier))
                {
                    bool isInheritedMember = IsInheritedMember(propertyInBase, property, templateBinding);
                    if(isInheritedMember)
                    {
                        return true;
                    }
                }
            }
        }

        return false;
    }

    /// <summary>
    /// Checks if the property is an inherited member.
    /// </summary>
    /// <param name="propertyInBase">The property in base</param>
    /// <param name="propertyInSubClass">The property in subclass</param>
    /// <param name="templateBinding">The template binding</param>
    /// <returns>true if the property in the subclass is an inherited member; false if it is not or the base is an interface</returns>
    private static bool IsInheritedMember(IProperty propertyInBase, IProperty propertyInSubClass, ITemplateBinding templateBinding)
    {
        var propertyInBaseOwner = propertyInBase.Owner;
        if(propertyInBaseOwner is IAssociation)
        {
            propertyInBaseOwner = ((IAssociation)propertyInBaseOwner).SourceElement;
        }

        if(propertyInBaseOwner is IInterface)
        {
            return false;
        }
        else if(propertyInBaseOwner is IClass)
        {
            bool isInheritedProperty = IsInheritedProperty(propertyInSubClass, propertyInBase, templateBinding);
            bool isOverridable = IsOverridable(propertyInBase, (IClass)propertyInBaseOwner);
            return isInheritedProperty && isOverridable;
        }
        
        return false;
    }
    
    /// <summary>
    /// Checks if the operation is an inherited member.
    /// </summary>
    /// <param name="operation">The operation</param>
    /// <param name="owner">The owning class of the operation</param>
    /// <returns>true if the operation is an inherited member.</returns>
    private static bool IsInheritedMember(IOperation operation, IClass owner)
    {
        var types = ImplementedOrInheritedTypes(owner);
        foreach(IType type in types) 
        {
            IClassifier baseClassifier = type as IClassifier;
            if(baseClassifier != null) 
            {
                ITemplateBinding templateBinding = GetTemplateBinding(baseClassifier);
                IClassifier bindingClassifier = GetBindingClassifier(templateBinding);
                if(bindingClassifier != null)
                {
                    baseClassifier = bindingClassifier;
                }

                foreach(IOperation operationInBase in GetOwnedOperations(baseClassifier))
                {
                    bool isInheritedMember = IsInheritedMember(operationInBase, operation, templateBinding);
                    if(isInheritedMember)
                    {
                        return true;
                    }
                }
            }
        }

        return false;
    }
    
    /// <summary>
    /// Checks if the operation is an inherited member.
    /// </summary>
    /// <param name="operationInBase">The operation in base</param>
    /// <param name="operationInSubClass">The operation in the subclass</param>
    /// <param name="templateBinding">The template binding</param>
    /// <returns>true if the operation in the subclass is an inherited member; false if it is not or the base is an interface</returns>
    private static bool IsInheritedMember(IOperation operationInBase, IOperation operationInSubClass, ITemplateBinding templateBinding)
    {
        var operationInBaseOwner = operationInBase.Owner;
        if(operationInBaseOwner is IAssociation)
        {
            operationInBaseOwner = ((IAssociation)operationInBaseOwner).SourceElement;
        }

        if(operationInBaseOwner is IInterface)
        {
            return false;
        }
        else if(operationInBaseOwner is IClass)
        {
            bool isInheritedOperation = IsInheritedOperation(operationInSubClass, operationInBase, templateBinding);
            bool isOverridable = IsOverridable(operationInBase, (IClass)operationInBaseOwner);
            return isInheritedOperation && isOverridable;
        }
        
        return false;
    }

    /// <summary>
    /// Checks if the operation in subclass is inherited from the operation in base.
    /// </summary>
    /// <param name="operationInSubClass">The operation in subClass</param>
    /// <param name="operationInBase">The operation in base</param>
    /// <param name="templateBinding">The template binding</param>
    /// <returns>if operation in subClass is inherited from the operation in base.</returns>
    private static bool IsInheritedOperation(IOperation operationInSubClass, IOperation operationInBase, ITemplateBinding templateBinding)
    {
        if(templateBinding == null)
        {
            return operationInSubClass.Signature == operationInBase.Signature;
        }

        if(operationInSubClass.Name != operationInBase.Name)
        {
            return false;
        }

        var subClassOperationOwnedParametersInOrder = GetOwnedParametersInOrder(operationInSubClass);
        var baseClassOperationOwnedParametersInOrder = GetOwnedParametersInOrder(operationInBase);
        int numOfSubClassOperationOwnedParameters = subClassOperationOwnedParametersInOrder.Count();
        if(numOfSubClassOperationOwnedParameters != baseClassOperationOwnedParametersInOrder.Count())
        {
            return false;
        }
       
        var parameterSubstitutions = templateBinding.ParameterSubstitutions;
         // find the newly defined template parameters
        var baseClassifier = (IClassifier)operationInBase.Owner;
        var subClassifier = (IClassifier)operationInSubClass.Owner;
        var subClassNewlyDefinedTemplateParameterNames = GetNewlyDefinedTemplateParameterNamesInSubClass(baseClassifier, subClassifier, parameterSubstitutions); 

        for(int i=0; i < numOfSubClassOperationOwnedParameters; i++)
        {
            var subClassOperationOwnedParameter = subClassOperationOwnedParametersInOrder.ElementAt(i);
            var baseClassOperationOwnedParameter = baseClassOperationOwnedParametersInOrder.ElementAt(i);
            if(subClassOperationOwnedParameter.Direction != baseClassOperationOwnedParameter.Direction)
            {
                return false;
            }

            bool isParameterInBaseEnumerable = IsEnumerable(baseClassOperationOwnedParameter);
            bool isParameterInSubClassEnumerable = IsEnumerable(subClassOperationOwnedParameter);
            if(isParameterInBaseEnumerable != isParameterInSubClassEnumerable)
            {
                return false;
            }

            if(!OneTypeOverridesTheOther(baseClassOperationOwnedParameter.Type, subClassOperationOwnedParameter.Type, parameterSubstitutions, subClassNewlyDefinedTemplateParameterNames))
            {
                return false;
            }
       }

       return true;
    }

    /// <summary>
    /// Gets the owned parameters in order: first is the parameter of return type, and then the rest of the parameters.
    /// </summary>
    /// <param name="operation">The operation</param>
    /// <returns>List of owned parameters in order</returns>
    private static List<IParameter> GetOwnedParametersInOrder(IOperation operation)
    {   
        var orderedSet = Enumerable.Union<IParameter>(operation.OwnedParameters.Where(parameter => parameter.Direction == ParameterDirectionKind.Return), operation.OwnedParameters.Where(parameter => parameter.Direction != ParameterDirectionKind.Return));
        return orderedSet.ToList();
    }

    /// <summary>
    /// Checks if the two type names are equal with considering of the template binding substitutions.
    /// </summary>
    /// <param name="propertyInSubClass">The property in subClass</param>
    /// <param name="propertyInBase">The property in base</param>
    /// <param name="templateBinding">The template binding</param>
    /// <returns>if property in subClass is inherited from the property in base.</returns>
    private static bool IsInheritedProperty(IProperty propertyInSubClass, IProperty propertyInBase, ITemplateBinding templateBinding)
    {
        if(templateBinding == null)
        {
            return propertyInSubClass.Signature == propertyInBase.Signature;
        }

        if(propertyInSubClass.Name != propertyInBase.Name)
        {
            return false;
        }
        
        bool isPropertyInBaseEnumerable = IsEnumerable(propertyInBase);
        bool isPropertyInSubClassEnumerable = IsEnumerable(propertyInSubClass);
        if(isPropertyInBaseEnumerable != isPropertyInSubClassEnumerable)
        {
            return false;
        }

        var parameterSubstitutions = templateBinding.ParameterSubstitutions;
        var subClassNewlyDefinedTemplateParameterNames = GetNewlyDefinedTemplateParameterNamesInSubClass(propertyInBase.Classifier, propertyInSubClass.Classifier, parameterSubstitutions); 

        return OneTypeOverridesTheOther(propertyInBase.Type, propertyInSubClass.Type, parameterSubstitutions, subClassNewlyDefinedTemplateParameterNames);
    }

    /// <summary>
    /// Checks if the type in subclass overrides the type in base.
    /// </summary>
    /// <param name="typeInBase">The type in base</param>
    /// <param name="typeInSubclass">The type in subclass</param>
    /// <param name="parameterSubstitutions">The parameter substitutions</param>
    /// <param name="newlyDefinedTemplateParameterNames">The newly defined template parameter names in subclass</param>
    /// <returns>true if the type in subclass overrides the type in the base; false otherwise</returns>
    private static bool OneTypeOverridesTheOther(IType typeInBase, IType typeInSubclass, IEnumerable<ITemplateParameterSubstitution> parameterSubstitutions, IEnumerable<string> newlyDefinedTemplateParameterNames)
    {
        // get name and template parameters for base
        List<string> baseTypeTemplateParametersNames = new List<string>();
        string baseTypeName = GetNameAndTemplateParameterNamesForType(typeInBase, out baseTypeTemplateParametersNames);

        // get name and template parameters for subclass
        List<string> subTypeTemplateParametersNames = new List<string>();
        string subTypeName = GetNameAndTemplateParameterNamesForType(typeInSubclass, out subTypeTemplateParametersNames);

        if(newlyDefinedTemplateParameterNames.Contains(subTypeName) || subTypeTemplateParametersNames.Where(name => newlyDefinedTemplateParameterNames.Contains(name)).Any())
        {
            return false;
        }

        int numberOfSubTypeTemplateParameters = subTypeTemplateParametersNames.Count();
        if(numberOfSubTypeTemplateParameters != baseTypeTemplateParametersNames.Count())
        {
            return false;
        }

        if(subTypeTemplateParametersNames.Any())
        {
            if(baseTypeName != subTypeName)
            {
                return false;
            }
            
            for(int i=0; i < numberOfSubTypeTemplateParameters; i++)
            {
                var subTypeTemplateParameterName = subTypeTemplateParametersNames.ElementAt(i);
                var baseTypeTemplateParameterName = baseTypeTemplateParametersNames.ElementAt(i);

                if(!OneTypeNameOverridesTheOther(baseTypeTemplateParameterName, subTypeTemplateParameterName, parameterSubstitutions))
                {
                    return false;
                }
            }

            return true;
        }
        else 
        {
            return OneTypeNameOverridesTheOther(baseTypeName, subTypeName, parameterSubstitutions);
        }
    }
    
    /// <summary>
    /// Checks if the type name in subclass overrides the type name in base.
    /// </summary>
    /// <param name="baseTypeName">The type name in base</param>
    /// <param name="subTypeName">The type name in subclass</param>
    /// <param name="parameterSubstitutions">The parameter substitutions</param>
    /// <returns>true if the type name in subclass could override the type in the base; false otherwise</returns>
    private static bool OneTypeNameOverridesTheOther(string baseTypeName, string subTypeName, IEnumerable<ITemplateParameterSubstitution> parameterSubstitutions)
    {
        bool found = false;
        bool hasSubstitution = false;
        foreach(var substitution in parameterSubstitutions)
        {
            if(substitution.Formal.ParameteredElement.Name == baseTypeName)
            {
                hasSubstitution = true;
                INamedElement actual = substitution.Actuals.FirstOrDefault();
                if(actual != null && subTypeName == actual.Name) 
                {
                    found = true;
                    break;
                }
            }
        }

        if(hasSubstitution && !found)
        {
            return false;
        }

        if(!hasSubstitution && baseTypeName != subTypeName)
        {
            return false;
        }

        return true;
    }

    /// <summary>
    /// Gets the name and template parameter names as a list for the given type.
    /// </summary>
    /// <param name="aType">the type to query</param>
    /// <param name="templateParameterNames">the template parameter names for the type</param>
    /// <returns>The type name</returns>
    private static string GetNameAndTemplateParameterNamesForType(IType aType, out List<string> templateParameterNames) 
    {
        string typeName = null;
        IClassifier classifier = aType as IClassifier;
        templateParameterNames = new List<string>();
        if(classifier != null)
        {
            templateParameterNames = GetNameAndTemplateParameterNamesForClassifier(classifier);
            if(templateParameterNames.Any())
            {
                typeName = templateParameterNames.ElementAt(0);
                templateParameterNames.RemoveAt(0);
            }
        }
        else 
        {
            typeName = ElementType(aType);
        }    

        return typeName;
    }

    /// <summary>
    /// Gets the classifier name and template parameter names as a list.
    /// </summary>
    /// <param name="classifier">the classifier to query</param>
    /// <returns>a list of classifier name and template parameter names for the given classifier</returns>
    private static List<string> GetNameAndTemplateParameterNamesForClassifier(IClassifier classifier) 
    {
        return ClassifierProperty(element => { return GetName(element); }, GetUnboundClassifierName, SimpleAssemble, classifier).ToList();
    }

    /// <summary>
    /// Gets the classifier name and template parameter names as a list.
    /// </summary>
    /// <param name="baseClass">the base class</param>
    /// <param name="subClass">the sub class</param>
    /// <param name="parameterSubstitutions">the parameter substitutions</param>
    /// <returns>The template parameter newly defined in the subclass</returns>
    private static IEnumerable<string> GetNewlyDefinedTemplateParameterNamesInSubClass(IClassifier baseClassifier, IClassifier subClassifier, IEnumerable<ITemplateParameterSubstitution> parameterSubstitutions)
    {
        var baseClassTemplateParameterNames = TemplateParameterNames(baseClassifier);
        var substitutedTemplateParameterNames = GetSubstitutedTemplateParameterNames(parameterSubstitutions);
        var nonSubstitutedTemplateParameterNames = baseClassTemplateParameterNames.Where(name => !substitutedTemplateParameterNames.Contains(name));

        var subClassTemplateParameterNames = TemplateParameterNames(subClassifier);
        return subClassTemplateParameterNames.Where(name => !nonSubstitutedTemplateParameterNames.Contains(name));
    }

    /// <summary>
    /// Gets the list of template parameter names that are substituted.
    /// </summary>
    /// <param name="parameterSubstitutions">the parameter substitutions</param>
    /// <returns>The list of template parameter names that are substituted.</returns>
    private static List<string> GetSubstitutedTemplateParameterNames(IEnumerable<ITemplateParameterSubstitution> templateParameterSubstitutions)
    {
        List<string> substitutedParameterNames = new List<string>();
        foreach(var substitute in templateParameterSubstitutions)
        {
            string formalName = substitute.Formal.ParameteredElement.Name;
            string actualName = null;
            if(substitute.Actuals.Any())
            {
                actualName = substitute.Actuals.ElementAt(0).Name;
            }

            if(!string.IsNullOrWhiteSpace(formalName))
            {
                if(!string.IsNullOrWhiteSpace(actualName) && formalName == actualName)
                {
                    continue;
                }
                else 
                {
                    substitutedParameterNames.Add(formalName);
                }
            }
        }

        return substitutedParameterNames;
    }

    /// <summary>
    /// Gets the owned attributes for the given classifier.
    /// </summary>
    /// <param name="classifier">The classifier</param>
    /// <returns>The owned attributes</returns>
    private static IEnumerable<IProperty> GetOwnedProperties(IClassifier classifier)
    {
        var ownedAttributes= GetOwnedAttributes(classifier);
        var navigableOwnedEnds = GetNavigableOwnedEnds(classifier, ownedAttributes);
        return Enumerable.Union<IProperty>(ownedAttributes, navigableOwnedEnds);
    }

    /// <summary>
    /// Gets the owned attributes for the given classifier.
    /// </summary>
    /// <param name="classifier">The classifier</param>
    /// <returns>The owned attributes</returns>
    private static IEnumerable<IProperty> GetOwnedAttributes(IClassifier classifier)
    {
        if(classifier is IClass)
        {
            return ((IClass)classifier).OwnedAttributes;
        }
        else if(classifier is IInterface)
        {
            return ((IInterface)classifier).OwnedAttributes;
        }

        return Enumerable.Empty<IProperty>();
    }

    /// <summary>
    /// Gets the owned operations for the given classifier.
    /// </summary>
    /// <param name="classifier">The classifier</param>
    /// <returns>The owned operations</returns>
    private static IEnumerable<IOperation> GetOwnedOperations(IClassifier classifier)
    {
        if(classifier is IClass)
        {
            return ((IClass)classifier).OwnedOperations;
        }
        else if(classifier is IInterface)
        {
            return ((IInterface)classifier).OwnedOperations;
        }

        return Enumerable.Empty<IOperation>();
    }

    #endregion Polymorphism
	
	#region Class property options

    /// <summary>
    /// Gets the sealed option.
    /// </summary>
    /// <param name="aClass">The class</param>
    /// <returns>The sealed keyword option</returns>
    private static string ClassSealedOption(IClass aClass)
    {
        return aClass.IsLeaf ? "sealed " : string.Empty;
    }

    /// <summary>
    /// Gets the abstract option.
    /// </summary>
    /// <param name="aClass">The class</param>
    /// <returns>The abstract keyword option</returns>
    private static string ClassAbstractOption(IClass aClass)
    {
        return aClass.IsAbstract ? "abstract " : string.Empty;
    }

    /// <summary>
    /// Gets the unsafe option.
    /// </summary>
    /// <param name="aClass">The class</param>
    /// <returns>The static keyword option</returns>
    private static string ClassUnsafeOption(IClass aClass) 
    {
        return GetProperty(aClass, "class", "IsUnsafe", "unsafe");
    }

	
    /// <summary>
    /// Gets the static option.
    /// </summary>
    /// <param name="aClass">The class</param>
    /// <returns>The static keyword option</returns>
    private static string ClassStaticOption(IClass aClass) 
    {
        return GetProperty(aClass, "class", "IsStatic", "static");
    }

    /// <summary>
    /// Gets the partial option.
    /// </summary>
    /// <param name="aClass">The class</param>
    /// <returns>The partial keyword option</returns>
    private static string ClassPartialOption(IClass aClass) 
    {
        return "partial ";//GetProperty(aClass, "class", "IsPartial", "partial");
    }

    #endregion Class property options
	
	#region Opertion
	/// <summary>
    /// Write UmlProperty definition.
    /// </summary>
    /// <param name="property">The uml IProperty</param>
    private void WriteClassUmlPropertyDefinition(IProperty property,bool IsGenerationAttribute)
    {							
        string overloadOption = ClassPropertyOverloadOption(property, this.Element);
        WriteUmlPropertyDefinition(property, overloadOption,IsGenerationAttribute);		
    }	
	
	/// <summary>
    /// 组合关系对应的属性
    /// </summary>
    /// <param name="property">The property</param>
    private void WriteAssociationPropertyForTelChina(IProperty property,bool IsGenerationAttribute,string description)
    {
		//string typeName =GetTelChinaPropertyNewType(property);	
		string typeName = GetNamespace((property.Type).Namespace)+"." + property.Type.Name;
		WriteAssociationPropertyForTelChina(property.Name,typeName,IsGenerationAttribute,description);				
    }
	
	/// <summary>
    /// 关联关系对应的属性
    /// </summary>
    /// <param name="dependency">The property</param>
    private void WriteDependencyPropertyForTelChina(IDependency dependency,bool IsGenerationAttribute)
    {
		string typeName = GetNamespace((dependency.Supplier).Namespace)+"." + dependency.Supplier.Name;
		
		WriteAssociationPropertyForTelChina(dependency.Name,typeName,IsGenerationAttribute,dependency.Description);		
    }
	
	/// <summary>
    /// 生成关系所有的对应的属性
    /// </summary>
    /// <param name="type">The property</param>
    private void WriteAssociationPropertyForTelChina(string name,string type, bool IsGenerationAttribute ,string description)
    {
		
		string smallfildName = FieldnameToSmall(name);
		string idFildName = "id"+name;
		string descriptionid =string.Empty;
		if(!string.IsNullOrEmpty(description))
		{
			descriptionid = description+"ID";
		}
		if(IsGenerationAttribute)
		{
			WritePrivatePropertyForTelChina(idFildName,"Guid",descriptionid);
			WritePublicGenerationPropertyForTelChina(idFildName,"Guid",descriptionid);
			
			WritePrivatePropertyForTelChina(name,type,description);
			WritePublicGenerationPropertyForTelChina(name,type,description);
		}
		else
		{
			WritePublicPropertyForTelChina(idFildName,"Guid",descriptionid);
			
			WritePublicPropertyForTelChina(name,type,description);			
		}		
    }
	
	/// <summary>
    /// 生成私有属性
    /// </summary>
    /// <param name="type">The property</param>
    private void WritePrivatePropertyForTelChina(string name, string type,string description)
    {		
		string smallfildName = FieldnameToSmall(name);
		WriteSummaryComment(description);    
		WriteLine("private "+ type + " " + smallfildName +";");
		WriteLine("");
    }
	
	/// <summary>
    /// 生成公共属性没有私有属性的
    /// </summary>
    /// <param name="type">The property</param>
    private void WritePublicPropertyForTelChina(string name, string type,string description)
    {	
		WriteSummaryComment(description);       
		WriteLine("public virtual "+ type +" " + name);
		WriteLine("{");
        PushIndent("\t");
		WriteLine("get;");
		WriteLine("set;");
		PopIndent();
        WriteLine("}");  
	}
	/// <summary>
    /// 生成公共属性含有私有属性的
    /// </summary>
    /// <param name="dependency">The property</param>
    private void WritePublicGenerationPropertyForTelChina(string name, string type,string description)
    {	
		string smallfildName = FieldnameToSmall(name);
		WriteSummaryComment(description);       
		Write("public virtual "+ type +" " + name);
		WriteLine("");
        WriteLine("{");
        PushIndent("\t");
		WriteLine("get");
		WriteLine("{");
        PushIndent("\t");
		WriteLine("return this."+smallfildName+";");
        PopIndent();
        WriteLine("}");
		WriteLine("set");
		WriteLine("{");
        PushIndent("\t");
		WriteLine("if (this."+smallfildName+" != value)");
        WriteLine("{");
		PushIndent("\t");
        WriteLine("RaisPropertyChangIngEvent(\""+smallfildName+"\");");		
        WriteLine(smallfildName +" = value;");
		WriteLine("RaisPropertyChangedEvent(\""+smallfildName + "\");");
        PopIndent();
        WriteLine("}");
		PopIndent();
        WriteLine("}");
		PopIndent();
		WriteLine("}");		
		WriteLine("");   
	}
	
	/// <summary>
    /// 生成关系所有的对应的属性
    /// </summary>
    /// <param name="type">The property</param>
    private void WriteCollectionPropertyForTelChina(IProperty property, bool IsGenerationAttribute,string description)
    {				
		string typeName = GetNamespace((property.Type).Namespace)+"." + property.Type.Name;
		string privateTypeName = typeName;
		string publicTypeName = typeName;
		bool isList = IsEnumerable(property);
		if(!isList)
		{
			//生成关联实体
			WriteAssociationPropertyForTelChina(property,IsGenerationAttribute,description);
			return;
		}
		privateTypeName ="ISet<" + typeName + "> ";
		publicTypeName ="ISet<" + typeName + "> ";
		string fildName = property.Name + "s";
		
		string smallfildName = FieldnameToSmall(fildName);
		//注释
		WriteSummaryComment(description);    
		//私有属性
		WriteLine("private " + privateTypeName + smallfildName +";");   
		WriteLine("");   			
		//注释
		WriteSummaryComment(description);	
		//属性
        WriteLine("public virtual "+ publicTypeName + fildName );
        WriteLine("{");
		PushIndent("\t");
        WriteLine("get");
		WriteLine("{");
        PushIndent("\t");
		WriteLine("if ("+smallfildName + "  == null)");
        WriteLine("{");
		PushIndent("\t");
		WriteLine(smallfildName + " = new HashedSet<"+ typeName +">();");
		PopIndent();
        WriteLine("}");		
        WriteLine("return this."+ smallfildName +";");
        PopIndent();
        WriteLine("}");
		WriteLine("set");
		WriteLine("{");
        PushIndent("\t");
        WriteLine(smallfildName + " = value;");
        PopIndent();
        WriteLine("}");
		PopIndent();
        WriteLine("}");
		WriteLine("");			
		/*
		WriteLine("public virtual ISet<" + typeName +"> Get" + fildName + "Set()");	
		WriteLine("{");
        PushIndent("\t");
        WriteLine("return " + smallfildName + ";");
        PopIndent();
        WriteLine("}");		
		WriteLine("");  
		*/
    }
	
	private void WriteChangeSetAndItemChanged(IProperty property, bool IsGenerationAttribute,string description)
	{
		string typeName = GetNamespace((property.Type).Namespace)+"." + property.Name;
		
		string fildName = property.Name + "s";
		string smallfildNames =FieldnameToSmall(fildName,"");
		string _smallfildName = FieldnameToSmall(fildName);
		string smallfildName =FieldnameToSmall(property.Name,"");
		string setItemChangedHandler = _smallfildName +"SetItemChangedHandler";
		string oppositeName =property.Opposite.Name;
		//事件		
		WriteSummaryComment(description+"改变事件");	
		WriteLine("private EventHandler<ItemChangedEventArgs<" + typeName +">> " + setItemChangedHandler+";");
		WriteLine("");
		//ChangeSet
		WriteSummaryComment(description+"改变");	
		WriteParameterComment(smallfildNames, description);
		WriteLine("private void ChangeSet(ISet<"+ typeName +"> "+ smallfildNames+")");
		WriteLine("{");
        PushIndent("\t");
		WriteLine("if ("+smallfildNames + "  == null)");
        WriteLine("{");
		PushIndent("\t");
		WriteLine("return;");
		PopIndent();
        WriteLine("}");
		WriteLine("if (this."+ setItemChangedHandler +" == null)");
        WriteLine("{");
		PushIndent("\t");
		WriteLine("this." + setItemChangedHandler + " = this.OnSetItemChanged;");
		PopIndent();
        WriteLine("}");
		WriteLine("if (this."+ _smallfildName +" != null)");
        WriteLine("{");
		PushIndent("\t");
		WriteLine("this." + _smallfildName + ".ItemChanged -= " + setItemChangedHandler+";");
		PopIndent();
        WriteLine("}");
		WriteLine("foreach (var "+ smallfildName+" in "+ smallfildNames +")");
        WriteLine("{");
		PushIndent("\t");
		WriteLine("this." + _smallfildName + ".Add( " + smallfildName + ");");
		PopIndent();
        WriteLine("}");
		WriteLine("this." + _smallfildName + ".ItemChanged += this.OnSetItemChanged;");
		PopIndent();
        WriteLine("}");
		WriteLine("");
		//SetItemChanged
		WriteSummaryComment(description+"子项变化");
		WriteParameterComment("e", description+"子项");
		WriteLine("private void OnSetItemChanged(object sender, ItemChangedEventArgs<"+ typeName + "> e)");
		WriteLine("{");
		PushIndent("\t");
		WriteLine("var "+ smallfildName + " = e.Item;");
		WriteLine("if (e.Type == ItemChangedType.Added)");
        WriteLine("{");
		PushIndent("\t");
		WriteLine("if ("+ smallfildName +"." + oppositeName + " != null)");
        WriteLine("{");
		PushIndent("\t");
		WriteLine(smallfildName +"."+ oppositeName +"."+ fildName +".Remove("+ smallfildName +");");
		PopIndent();
        WriteLine("}");
		WriteLine(smallfildName +"." + oppositeName + " = this;");
		PopIndent();
        WriteLine("}");
		WriteLine("else");
        WriteLine("{");
		PushIndent("\t");
		WriteLine(smallfildName +"." + oppositeName + " = null;");
		PopIndent();
        WriteLine("}");
		PopIndent();
        WriteLine("}");
		WriteLine("");		
	}
	#endregion Opertion
	
    #region Visibility
    /// <summary>
    /// Returns the visibility of the given class.
    /// </summary>
    /// <param name="aClass">The class</param>
    /// <returns>public, protected, protected internal, internal, or private</returns>
    private static string ClassVisibility(IClass aClass)
    {
        return Visibility(aClass, "class", "PackageVisibility");
    }

	private void WriteTelChinaClassClrAttributes(IClass element)
    {
		bool isDTO = false;
		//是否为DTO
		string isClassDTO = GetTelChinaProperty(this.Element, "DTOBase", "IsDTO");
		if(!string.IsNullOrEmpty(isClassDTO)&&isClassDTO=="true")
		{
			isDTO =true;
		}
		if(!isDTO)
		{			
	        string classNamespace =GetNamespace(this.Element.Namespace);
			string assemblyName =string.Empty;
			//模版路径
			string projectPath = this.Element.GetModelStore().Root.GetStereotypeProperty("TextTemplateBindings","TextTemplateBindings","ProjectPath");
			var paths = projectPath.Split('|');
			foreach(string path in paths)
			{
				if(path.Contains("TelChinaInterfaceTemplate"))
				{
					var projects =path.Split(new char[1]{'\\'});
					foreach(string project in projects)
					{
						if(project.Contains(".csproj"))
						{
							assemblyName =project.Replace(".csproj","");
						}
					}
				}
			}
			if(string.IsNullOrEmpty(assemblyName))
			{
				assemblyName =classNamespace;
			}
			string className =classNamespace+"."+ClassifierName(this.Element)+"DTO";
			
			WriteLine("[DataContractTrsolverArrtibute(TypeAssemly=\""+ assemblyName +"\",TypeFullName=\""+className+"\")]");
		}
    }
    #endregion Visibility
#>
<#+
    protected override bool AppliesToElement()
    {	
		bool isDTO = false;
		//是否为DTO
		string isClassDTO = GetTelChinaProperty(this.Element, "DTOBase", "IsDTO");
		if(!string.IsNullOrEmpty(isClassDTO)&&isClassDTO=="true")
		{
			isDTO =true;
		}
        bool isTemplate = this.Element.IsTemplate;
        bool isBoundElement = this.Element.TemplateBindings != null && this.Element.TemplateBindings.Any();
        return !isTemplate && !isBoundElement && GetStereotype(this.Element) == "class" && !isDTO;
    }
#>
