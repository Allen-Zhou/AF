<#@ Include File="TelChinaTemplateHeader.t4" #>
<#@ Modeling ElementType="Microsoft.VisualStudio.Uml.Classes.IClass" Processor="ModelingProcessor" ApplyStereotypes="CSharp" #>
<#@ Assembly Name="Microsoft.VisualStudio.ArchitectureTools.Extensibility, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL" #>
<#@ Import Namespace="Microsoft.VisualStudio.Uml.AuxiliaryConstructs" #>
<#@ Import Namespace="Microsoft.VisualStudio.Uml.Classes" #>
<#@ Import Namespace="Microsoft.VisualStudio.ArchitectureTools.Extensibility.Uml" #>
<#@ Include File="TelChinaCSharpCommentHelpers.t4" #>
<#@ Include File="TelChinaCSharpHelpers.t4" #>
<#@ Output Extension=".cs" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
<# 
	//System.Diagnostics.Debugger.Launch(); 
    //using集合
	WriteUsingStatements(this.Element,"EntityBase");
    WriteLine("");
	string classNamespace =this.Element.Namespace.ToString();
	classNamespace=GetNamespace(this.Element.Namespace);
    if(!string.IsNullOrEmpty(classNamespace))
    {
#>
namespace <#= classNamespace #>
{
<#   
		 PushIndent("\t");
    }	
	
#>
<#
	//特性类
    WriteClassClrAttributes(this.Element);
#>
<#= ClassVisibility(this.Element) #><#= ClassUnsafeOption(this.Element) #><#= ClassStaticOption(this.Element) #><#= ClassAbstractOption(this.Element) #><#= ClassSealedOption(this.Element) #><#= ClassPartialOption(this.Element) #>class <#= ClassifierName(this.Element) #><#= ImplementedAndInheritedList(this.Element) #>
{
 	/// <summary>
    /// auto-generated:设置本实体上的字段默认值,应用开发扩展点
    /// </summary>
    protected override void SetDefaultValue()
    {
        
    }
	/// <summary>
    /// auto-generated:执行字段合法性检查,应用开发扩展点
    /// </summary>
    protected override void OnValidate()
    {
       
    }
	/// <summary>
    /// auto-generated:新增保存的前置条件
    /// </summary>
    protected override void OnInserting()
    {
        
    }
 	/// <summary>
    /// auto-generated:新增保存的后置条件
    /// </summary>
    protected override void OnInserted()
    {
       
    }
	/// <summary>
    /// auto-generated:修改保存的前置条件
    /// </summary>
    protected override void OnUpdating()
    {
        
    }
	/// <summary>
    /// auto-generated:修改保存的后置条件
    /// </summary>
    protected override void OnUpdated()
    {
       
    }
	/// <summary>
    /// auto-generated:删除的前置条件
    /// </summary>
    protected override void OnDeleting()
    {
        
    }
	/// <summary>
    /// auto-generated:删除的后置条件
    /// </summary>
	protected override void OnDeleted()
    {
       
    }
}
<#
    ClearIndent();
    if(!string.IsNullOrEmpty(classNamespace))
    {
#>
}
<#  } #>


<#+   
	#region Inheritance

    /// <summary>
    /// Gets the implemented and inherited types of the given class.
    /// </summary>
    /// <param name="aClass">The given class</param>
    /// <returns>implementedAndInherted types</returns>
    private static string ImplementedAndInheritedList(IClass aClass)
    {		
        var list = ImplementedAndInheritedTypes(aClass);
        if(list.Any())
        {         
			
			return " : " + string.Join(", ", list.Select(t => ElementClassType(t)));			
        }
        else
        {	
			if(aClass.Name =="PropertyMetaDataAttribute")
			{
				return " : Attribute";
			}
            return " : EntityBase";
        }
    }

    #endregion Inheritance
	
	 #region Polymorphism

    /// <summary>
    /// Gets the overload option of the indexer.
    /// </summary>
    /// <param name="operation">The operation</param>
    /// <param name="owner">The class</param>
    /// <returns>The overload option for the operation</returns>
    private static string ClassIndexerOverloadOption(IOperation operation, IClass owner)
    {
        return ClassOperationOverloadOption(operation, owner);
    }

    /// <summary>
    /// Gets the overload option of the method.
    /// </summary>
    /// <param name="operation">The operation</param>
    /// <param name="owner">The class</param>
    /// <returns>The overload option for the operation</returns>
    private static string ClassMethodOverloadOption(IOperation operation, IClass owner)
    {
        if(string.IsNullOrEmpty(MethodPartialOption(operation)))
        {
            return ClassOperationOverloadOption(operation, owner);
        }
        else 
        {
            return string.Empty;
        }
    }

    /// <summary>
    /// Gets the overload option of the operation.
    /// </summary>
    /// <param name="operation">The operation</param>
    /// <param name="owner">The class</param>
    /// <returns>The overload option for the operation</returns>
    private static string ClassOperationOverloadOption(IOperation operation, IClass owner)
    {
        string overload = string.Empty;
        if(!string.IsNullOrEmpty(OperationAbstractOption(operation)))
        {
            overload += "abstract ";
        }
        else if(IsInheritedMember(operation, owner))
        {
            overload += "override ";
            if(!string.IsNullOrEmpty(OperationSealedOption(operation)))
            {
                overload += "sealed ";
            }
        }
        else if(IsOverridable(operation, owner))
        {
            overload += "virtual ";
        }

        return overload;
    }

    /// <summary>
    /// Gets the overload option of the property.
    /// </summary>
    /// <param name="property">The property</param>
    /// <param name="owner">The class</param>
    /// <returns>The overload option for the property</returns>
    private static string ClassPropertyOverloadOption(IProperty property, IClass owner)
    {
        string overload = string.Empty;
        if(IsInheritedMember(property, owner))
        {
            overload = "override ";
            if(!string.IsNullOrEmpty(PropertySealedOption(property)))
            {
                overload += "sealed ";
            }
        }
        else if(IsOverridable(property, owner))
        {
            overload += "virtual ";
        }

        return overload;
    }

    /// <summary>
    /// Checks if the operation is overridable.
    /// </summary>
    /// <param name="operation">The operation</param>
    /// <param name="owner">The class</param>
    /// <returns>true if the operation is an inherited member.</returns>
    private static bool IsOverridable(IOperation operation, IClass owner)
    {
        bool isPrivate = MethodVisibility(operation) == "private " || IndexerVisibility(operation) == "private ";
        return !isPrivate && string.IsNullOrEmpty(OperationStaticOption(operation)) && string.IsNullOrEmpty(OperationSealedOption(operation)) && HasVirtualMembers(owner);
    }

    /// <summary>
    /// Checks if the property is overridable.
    /// </summary>
    /// <param name="property">The property</param>
    /// <param name="owner">The class</param>
    /// <returns>true if the property is an inherited member.</returns>
    private static bool IsOverridable(IProperty property, IClass owner)
    {
        bool isPrivate = FieldVisibility(property) == "private " || PropertyVisibility(property) == "private ";
        return !isPrivate && string.IsNullOrEmpty(AttributeStaticOption(property)) && string.IsNullOrEmpty(PropertySealedOption(property)) && HasVirtualMembers(owner);
    }

    /// <summary>
    /// Checks if the classifier could have virtual memebers.
    /// </summary>
    /// <param name="aClass">The class</param>
    /// <returns>true if the property is an inherited member.</returns>
    private static bool HasVirtualMembers(IClass aClass)
    {
        return string.IsNullOrEmpty(ClassSealedOption(aClass)) && string.IsNullOrEmpty(ClassStaticOption(aClass));
    }

    /// <summary>
    /// Checks if the property is an inherited member.
    /// </summary>
    /// <param name="property">The property</param>
    /// <param name="owner">The owner class of the property</param>
    /// <returns>true if the property is an inherited member.</returns>
    private static bool IsInheritedMember(IProperty property, IClass owner)
    {
        var types = ImplementedOrInheritedTypes(owner);
        foreach(IType type in types) 
        {
            IClassifier baseClassifier = type as IClassifier;
            if(baseClassifier != null) 
            {
                ITemplateBinding templateBinding = GetTemplateBinding(baseClassifier);
                IClassifier bindingClassifier = GetBindingClassifier(templateBinding);
                if(bindingClassifier != null)
                {
					
                    baseClassifier = bindingClassifier;
                }

                foreach(IProperty propertyInBase in GetOwnedProperties(baseClassifier))
                {
                    bool isInheritedMember = IsInheritedMember(propertyInBase, property, templateBinding);
                    if(isInheritedMember)
                    {
                        return true;
                    }
                }
            }
        }

        return false;
    }

    /// <summary>
    /// Checks if the property is an inherited member.
    /// </summary>
    /// <param name="propertyInBase">The property in base</param>
    /// <param name="propertyInSubClass">The property in subclass</param>
    /// <param name="templateBinding">The template binding</param>
    /// <returns>true if the property in the subclass is an inherited member; false if it is not or the base is an interface</returns>
    private static bool IsInheritedMember(IProperty propertyInBase, IProperty propertyInSubClass, ITemplateBinding templateBinding)
    {
        var propertyInBaseOwner = propertyInBase.Owner;
        if(propertyInBaseOwner is IAssociation)
        {
            propertyInBaseOwner = ((IAssociation)propertyInBaseOwner).SourceElement;
        }

        if(propertyInBaseOwner is IInterface)
        {
            return false;
        }
        else if(propertyInBaseOwner is IClass)
        {
            bool isInheritedProperty = IsInheritedProperty(propertyInSubClass, propertyInBase, templateBinding);
            bool isOverridable = IsOverridable(propertyInBase, (IClass)propertyInBaseOwner);
            return isInheritedProperty && isOverridable;
        }
        
        return false;
    }
    
    /// <summary>
    /// Checks if the operation is an inherited member.
    /// </summary>
    /// <param name="operation">The operation</param>
    /// <param name="owner">The owning class of the operation</param>
    /// <returns>true if the operation is an inherited member.</returns>
    private static bool IsInheritedMember(IOperation operation, IClass owner)
    {
        var types = ImplementedOrInheritedTypes(owner);
        foreach(IType type in types) 
        {
            IClassifier baseClassifier = type as IClassifier;
            if(baseClassifier != null) 
            {
                ITemplateBinding templateBinding = GetTemplateBinding(baseClassifier);
                IClassifier bindingClassifier = GetBindingClassifier(templateBinding);
                if(bindingClassifier != null)
                {
                    baseClassifier = bindingClassifier;
                }

                foreach(IOperation operationInBase in GetOwnedOperations(baseClassifier))
                {
                    bool isInheritedMember = IsInheritedMember(operationInBase, operation, templateBinding);
                    if(isInheritedMember)
                    {
                        return true;
                    }
                }
            }
        }

        return false;
    }
    
    /// <summary>
    /// Checks if the operation is an inherited member.
    /// </summary>
    /// <param name="operationInBase">The operation in base</param>
    /// <param name="operationInSubClass">The operation in the subclass</param>
    /// <param name="templateBinding">The template binding</param>
    /// <returns>true if the operation in the subclass is an inherited member; false if it is not or the base is an interface</returns>
    private static bool IsInheritedMember(IOperation operationInBase, IOperation operationInSubClass, ITemplateBinding templateBinding)
    {
        var operationInBaseOwner = operationInBase.Owner;
        if(operationInBaseOwner is IAssociation)
        {
            operationInBaseOwner = ((IAssociation)operationInBaseOwner).SourceElement;
        }

        if(operationInBaseOwner is IInterface)
        {
            return false;
        }
        else if(operationInBaseOwner is IClass)
        {
            bool isInheritedOperation = IsInheritedOperation(operationInSubClass, operationInBase, templateBinding);
            bool isOverridable = IsOverridable(operationInBase, (IClass)operationInBaseOwner);
            return isInheritedOperation && isOverridable;
        }
        
        return false;
    }

    /// <summary>
    /// Checks if the operation in subclass is inherited from the operation in base.
    /// </summary>
    /// <param name="operationInSubClass">The operation in subClass</param>
    /// <param name="operationInBase">The operation in base</param>
    /// <param name="templateBinding">The template binding</param>
    /// <returns>if operation in subClass is inherited from the operation in base.</returns>
    private static bool IsInheritedOperation(IOperation operationInSubClass, IOperation operationInBase, ITemplateBinding templateBinding)
    {
        if(templateBinding == null)
        {
            return operationInSubClass.Signature == operationInBase.Signature;
        }

        if(operationInSubClass.Name != operationInBase.Name)
        {
            return false;
        }

        var subClassOperationOwnedParametersInOrder = GetOwnedParametersInOrder(operationInSubClass);
        var baseClassOperationOwnedParametersInOrder = GetOwnedParametersInOrder(operationInBase);
        int numOfSubClassOperationOwnedParameters = subClassOperationOwnedParametersInOrder.Count();
        if(numOfSubClassOperationOwnedParameters != baseClassOperationOwnedParametersInOrder.Count())
        {
            return false;
        }
       
        var parameterSubstitutions = templateBinding.ParameterSubstitutions;
         // find the newly defined template parameters
        var baseClassifier = (IClassifier)operationInBase.Owner;
        var subClassifier = (IClassifier)operationInSubClass.Owner;
        var subClassNewlyDefinedTemplateParameterNames = GetNewlyDefinedTemplateParameterNamesInSubClass(baseClassifier, subClassifier, parameterSubstitutions); 

        for(int i=0; i < numOfSubClassOperationOwnedParameters; i++)
        {
            var subClassOperationOwnedParameter = subClassOperationOwnedParametersInOrder.ElementAt(i);
            var baseClassOperationOwnedParameter = baseClassOperationOwnedParametersInOrder.ElementAt(i);
            if(subClassOperationOwnedParameter.Direction != baseClassOperationOwnedParameter.Direction)
            {
                return false;
            }

            bool isParameterInBaseEnumerable = IsEnumerable(baseClassOperationOwnedParameter);
            bool isParameterInSubClassEnumerable = IsEnumerable(subClassOperationOwnedParameter);
            if(isParameterInBaseEnumerable != isParameterInSubClassEnumerable)
            {
                return false;
            }

            if(!OneTypeOverridesTheOther(baseClassOperationOwnedParameter.Type, subClassOperationOwnedParameter.Type, parameterSubstitutions, subClassNewlyDefinedTemplateParameterNames))
            {
                return false;
            }
       }

       return true;
    }

    /// <summary>
    /// Gets the owned parameters in order: first is the parameter of return type, and then the rest of the parameters.
    /// </summary>
    /// <param name="operation">The operation</param>
    /// <returns>List of owned parameters in order</returns>
    private static List<IParameter> GetOwnedParametersInOrder(IOperation operation)
    {   
        var orderedSet = Enumerable.Union<IParameter>(operation.OwnedParameters.Where(parameter => parameter.Direction == ParameterDirectionKind.Return), operation.OwnedParameters.Where(parameter => parameter.Direction != ParameterDirectionKind.Return));
        return orderedSet.ToList();
    }

    /// <summary>
    /// Checks if the two type names are equal with considering of the template binding substitutions.
    /// </summary>
    /// <param name="propertyInSubClass">The property in subClass</param>
    /// <param name="propertyInBase">The property in base</param>
    /// <param name="templateBinding">The template binding</param>
    /// <returns>if property in subClass is inherited from the property in base.</returns>
    private static bool IsInheritedProperty(IProperty propertyInSubClass, IProperty propertyInBase, ITemplateBinding templateBinding)
    {
        if(templateBinding == null)
        {
            return propertyInSubClass.Signature == propertyInBase.Signature;
        }

        if(propertyInSubClass.Name != propertyInBase.Name)
        {
            return false;
        }
        
        bool isPropertyInBaseEnumerable = IsEnumerable(propertyInBase);
        bool isPropertyInSubClassEnumerable = IsEnumerable(propertyInSubClass);
        if(isPropertyInBaseEnumerable != isPropertyInSubClassEnumerable)
        {
            return false;
        }

        var parameterSubstitutions = templateBinding.ParameterSubstitutions;
        var subClassNewlyDefinedTemplateParameterNames = GetNewlyDefinedTemplateParameterNamesInSubClass(propertyInBase.Classifier, propertyInSubClass.Classifier, parameterSubstitutions); 

        return OneTypeOverridesTheOther(propertyInBase.Type, propertyInSubClass.Type, parameterSubstitutions, subClassNewlyDefinedTemplateParameterNames);
    }

    /// <summary>
    /// Checks if the type in subclass overrides the type in base.
    /// </summary>
    /// <param name="typeInBase">The type in base</param>
    /// <param name="typeInSubclass">The type in subclass</param>
    /// <param name="parameterSubstitutions">The parameter substitutions</param>
    /// <param name="newlyDefinedTemplateParameterNames">The newly defined template parameter names in subclass</param>
    /// <returns>true if the type in subclass overrides the type in the base; false otherwise</returns>
    private static bool OneTypeOverridesTheOther(IType typeInBase, IType typeInSubclass, IEnumerable<ITemplateParameterSubstitution> parameterSubstitutions, IEnumerable<string> newlyDefinedTemplateParameterNames)
    {
        // get name and template parameters for base
        List<string> baseTypeTemplateParametersNames = new List<string>();
        string baseTypeName = GetNameAndTemplateParameterNamesForType(typeInBase, out baseTypeTemplateParametersNames);

        // get name and template parameters for subclass
        List<string> subTypeTemplateParametersNames = new List<string>();
        string subTypeName = GetNameAndTemplateParameterNamesForType(typeInSubclass, out subTypeTemplateParametersNames);

        if(newlyDefinedTemplateParameterNames.Contains(subTypeName) || subTypeTemplateParametersNames.Where(name => newlyDefinedTemplateParameterNames.Contains(name)).Any())
        {
            return false;
        }

        int numberOfSubTypeTemplateParameters = subTypeTemplateParametersNames.Count();
        if(numberOfSubTypeTemplateParameters != baseTypeTemplateParametersNames.Count())
        {
            return false;
        }

        if(subTypeTemplateParametersNames.Any())
        {
            if(baseTypeName != subTypeName)
            {
                return false;
            }
            
            for(int i=0; i < numberOfSubTypeTemplateParameters; i++)
            {
                var subTypeTemplateParameterName = subTypeTemplateParametersNames.ElementAt(i);
                var baseTypeTemplateParameterName = baseTypeTemplateParametersNames.ElementAt(i);

                if(!OneTypeNameOverridesTheOther(baseTypeTemplateParameterName, subTypeTemplateParameterName, parameterSubstitutions))
                {
                    return false;
                }
            }

            return true;
        }
        else 
        {
            return OneTypeNameOverridesTheOther(baseTypeName, subTypeName, parameterSubstitutions);
        }
    }
    
    /// <summary>
    /// Checks if the type name in subclass overrides the type name in base.
    /// </summary>
    /// <param name="baseTypeName">The type name in base</param>
    /// <param name="subTypeName">The type name in subclass</param>
    /// <param name="parameterSubstitutions">The parameter substitutions</param>
    /// <returns>true if the type name in subclass could override the type in the base; false otherwise</returns>
    private static bool OneTypeNameOverridesTheOther(string baseTypeName, string subTypeName, IEnumerable<ITemplateParameterSubstitution> parameterSubstitutions)
    {
        bool found = false;
        bool hasSubstitution = false;
        foreach(var substitution in parameterSubstitutions)
        {
            if(substitution.Formal.ParameteredElement.Name == baseTypeName)
            {
                hasSubstitution = true;
                INamedElement actual = substitution.Actuals.FirstOrDefault();
                if(actual != null && subTypeName == actual.Name) 
                {
                    found = true;
                    break;
                }
            }
        }

        if(hasSubstitution && !found)
        {
            return false;
        }

        if(!hasSubstitution && baseTypeName != subTypeName)
        {
            return false;
        }

        return true;
    }

    /// <summary>
    /// Gets the name and template parameter names as a list for the given type.
    /// </summary>
    /// <param name="aType">the type to query</param>
    /// <param name="templateParameterNames">the template parameter names for the type</param>
    /// <returns>The type name</returns>
    private static string GetNameAndTemplateParameterNamesForType(IType aType, out List<string> templateParameterNames) 
    {
        string typeName = null;
        IClassifier classifier = aType as IClassifier;
        templateParameterNames = new List<string>();
        if(classifier != null)
        {
            templateParameterNames = GetNameAndTemplateParameterNamesForClassifier(classifier);
            if(templateParameterNames.Any())
            {
                typeName = templateParameterNames.ElementAt(0);
                templateParameterNames.RemoveAt(0);
            }
        }
        else 
        {
            typeName = ElementType(aType);
        }    

        return typeName;
    }

    /// <summary>
    /// Gets the classifier name and template parameter names as a list.
    /// </summary>
    /// <param name="classifier">the classifier to query</param>
    /// <returns>a list of classifier name and template parameter names for the given classifier</returns>
    private static List<string> GetNameAndTemplateParameterNamesForClassifier(IClassifier classifier) 
    {
        return ClassifierProperty(element => { return GetName(element); }, GetUnboundClassifierName, SimpleAssemble, classifier).ToList();
    }

    /// <summary>
    /// Gets the classifier name and template parameter names as a list.
    /// </summary>
    /// <param name="baseClass">the base class</param>
    /// <param name="subClass">the sub class</param>
    /// <param name="parameterSubstitutions">the parameter substitutions</param>
    /// <returns>The template parameter newly defined in the subclass</returns>
    private static IEnumerable<string> GetNewlyDefinedTemplateParameterNamesInSubClass(IClassifier baseClassifier, IClassifier subClassifier, IEnumerable<ITemplateParameterSubstitution> parameterSubstitutions)
    {
        var baseClassTemplateParameterNames = TemplateParameterNames(baseClassifier);
        var substitutedTemplateParameterNames = GetSubstitutedTemplateParameterNames(parameterSubstitutions);
        var nonSubstitutedTemplateParameterNames = baseClassTemplateParameterNames.Where(name => !substitutedTemplateParameterNames.Contains(name));

        var subClassTemplateParameterNames = TemplateParameterNames(subClassifier);
        return subClassTemplateParameterNames.Where(name => !nonSubstitutedTemplateParameterNames.Contains(name));
    }

    /// <summary>
    /// Gets the list of template parameter names that are substituted.
    /// </summary>
    /// <param name="parameterSubstitutions">the parameter substitutions</param>
    /// <returns>The list of template parameter names that are substituted.</returns>
    private static List<string> GetSubstitutedTemplateParameterNames(IEnumerable<ITemplateParameterSubstitution> templateParameterSubstitutions)
    {
        List<string> substitutedParameterNames = new List<string>();
        foreach(var substitute in templateParameterSubstitutions)
        {
            string formalName = substitute.Formal.ParameteredElement.Name;
            string actualName = null;
            if(substitute.Actuals.Any())
            {
                actualName = substitute.Actuals.ElementAt(0).Name;
            }

            if(!string.IsNullOrWhiteSpace(formalName))
            {
                if(!string.IsNullOrWhiteSpace(actualName) && formalName == actualName)
                {
                    continue;
                }
                else 
                {
                    substitutedParameterNames.Add(formalName);
                }
            }
        }

        return substitutedParameterNames;
    }

    /// <summary>
    /// Gets the owned attributes for the given classifier.
    /// </summary>
    /// <param name="classifier">The classifier</param>
    /// <returns>The owned attributes</returns>
    private static IEnumerable<IProperty> GetOwnedProperties(IClassifier classifier)
    {
        var ownedAttributes= GetOwnedAttributes(classifier);
        var navigableOwnedEnds = GetNavigableOwnedEnds(classifier, ownedAttributes);
        return Enumerable.Union<IProperty>(ownedAttributes, navigableOwnedEnds);
    }

    /// <summary>
    /// Gets the owned attributes for the given classifier.
    /// </summary>
    /// <param name="classifier">The classifier</param>
    /// <returns>The owned attributes</returns>
    private static IEnumerable<IProperty> GetOwnedAttributes(IClassifier classifier)
    {
        if(classifier is IClass)
        {
            return ((IClass)classifier).OwnedAttributes;
        }
        else if(classifier is IInterface)
        {
            return ((IInterface)classifier).OwnedAttributes;
        }

        return Enumerable.Empty<IProperty>();
    }

    /// <summary>
    /// Gets the owned operations for the given classifier.
    /// </summary>
    /// <param name="classifier">The classifier</param>
    /// <returns>The owned operations</returns>
    private static IEnumerable<IOperation> GetOwnedOperations(IClassifier classifier)
    {
        if(classifier is IClass)
        {
            return ((IClass)classifier).OwnedOperations;
        }
        else if(classifier is IInterface)
        {
            return ((IInterface)classifier).OwnedOperations;
        }

        return Enumerable.Empty<IOperation>();
    }

    #endregion Polymorphism
	
	#region Class property options

    /// <summary>
    /// Gets the sealed option.
    /// </summary>
    /// <param name="aClass">The class</param>
    /// <returns>The sealed keyword option</returns>
    private static string ClassSealedOption(IClass aClass)
    {
        return aClass.IsLeaf ? "sealed " : string.Empty;
    }

    /// <summary>
    /// Gets the abstract option.
    /// </summary>
    /// <param name="aClass">The class</param>
    /// <returns>The abstract keyword option</returns>
    private static string ClassAbstractOption(IClass aClass)
    {
        return aClass.IsAbstract ? "abstract " : string.Empty;
    }

    /// <summary>
    /// Gets the unsafe option.
    /// </summary>
    /// <param name="aClass">The class</param>
    /// <returns>The static keyword option</returns>
    private static string ClassUnsafeOption(IClass aClass) 
    {
        return GetProperty(aClass, "class", "IsUnsafe", "unsafe");
    }

	
    /// <summary>
    /// Gets the static option.
    /// </summary>
    /// <param name="aClass">The class</param>
    /// <returns>The static keyword option</returns>
    private static string ClassStaticOption(IClass aClass) 
    {
        return GetProperty(aClass, "class", "IsStatic", "static");
    }

    /// <summary>
    /// Gets the partial option.
    /// </summary>
    /// <param name="aClass">The class</param>
    /// <returns>The partial keyword option</returns>
    private static string ClassPartialOption(IClass aClass) 
    {
        return "partial ";//GetProperty(aClass, "class", "IsPartial", "partial");
    }

    #endregion Class property options
	
	#region Opertion
	/// <summary>
    /// Write UmlProperty definition.
    /// </summary>
    /// <param name="property">The uml IProperty</param>
    private void WriteClassUmlPropertyDefinition(IProperty property)
    {							
        string overloadOption = ClassPropertyOverloadOption(property, this.Element);
        WriteUmlPropertyDefinition(property, overloadOption);
    }	
	
	#endregion Opertion
	
    #region Visibility
    /// <summary>
    /// Returns the visibility of the given class.
    /// </summary>
    /// <param name="aClass">The class</param>
    /// <returns>public, protected, protected internal, internal, or private</returns>
    private static string ClassVisibility(IClass aClass)
    {
        return Visibility(aClass, "class", "PackageVisibility");
    }

	
    #endregion Visibility
#>
<#+
    protected override bool AppliesToElement()
    {	
		/*
		bool isExends =false;
		//string patha =System.IO.Path.GetDirectoryName("EntityBase.cs");
		var  projectofPaths =this.Element.GetStereotypeProperty("TextTemplateBindings", "TextTemplateBindings", "ProjectPath");
		//var  targetofName =this.Element.GetStereotypeProperty("TextTemplateBindings", "TextTemplateBindings", "TargetName");
		if(!string.IsNullOrEmpty(projectofPaths))
		{
			string projectPath = string.Empty;
			var projectPaths =projectofPaths.ToString().Split('|');
			if(projectPaths.Length>1)
			{
				projectPath = projectPaths[1];
			}
			else
			{
				projectPath = projectPaths[0];
			}
			string packName =string.Join("\\", NamespaceHierarchy(this.Element.Namespace).Select(ns => ns.Name));
			projectPath =projectPath.Split('=')[1];
			var projectTruePath = projectPath.Split('\\');
			string truePath =string.Empty;
			for(int i =0;i<projectTruePath.Length-1;i++)
			{
				if(string.IsNullOrEmpty(truePath))
				{
					truePath=projectTruePath[i];
				}
				else
				{
					truePath +="\\"+ projectTruePath[i];
				}
			}
			ITextTemplatingEngineHost h = Host;
			//string sourceCsdlPath	= h.ResolveParameterValue("belogic","belogicexe","sourceCsdlPath");
			projectPath =projectPath.Substring(0,projectPath.Length-7);					
		 	if(System.IO.File.Exists(truePath+"\\"+packName+"\\"+this.Element.Name+".cs"))
			{
				isExends=true;
			}
		}*/
		bool isOutPut = true;
		string className =ClassifierName(this.Element);
		if(className == "EntityBase")
		{
			isOutPut = false;
		}
		bool isDTO = false;
		//是否为DTO
		string isClassDTO = GetTelChinaProperty(this.Element, "DTOBase", "IsDTO");
		if(!string.IsNullOrEmpty(isClassDTO)&&isClassDTO=="true")
		{
			isDTO =true;
		}
        bool isTemplate = this.Element.IsTemplate;
        bool isBoundElement = this.Element.TemplateBindings != null && this.Element.TemplateBindings.Any();
        return !isTemplate && !isBoundElement && GetStereotype(this.Element) == "class" && isOutPut && !isDTO;
    }
#>
