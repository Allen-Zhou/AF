<#@ Include File="TelChinaTemplateHeader.t4" #>
<#@ Modeling ElementType="Microsoft.VisualStudio.Uml.Classes.IInterface" Processor="ModelingProcessor" ApplyStereotypes="CSharp" #>
<#@ Assembly Name="Microsoft.VisualStudio.ArchitectureTools.Extensibility, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL" #>
<#@ Import Namespace="System.Linq" #>
<#@ Import Namespace="System.Text" #>
<#@ Import Namespace="Microsoft.VisualStudio.ArchitectureTools.Extensibility.Uml" #>
<#@ Import Namespace="Microsoft.VisualStudio.Uml.Classes" #>
<#@ Import Namespace="System.Collections" #>
<#@ Include File="TelChinaCSharpCommentHelpers.t4" #>
<#@ Include File="TelChinaCSharpHelpers.t4" #>
<#@ Output Extension=".cs" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
<# IInterface interfaceElement = this.Element as IInterface; #>
<# 
	//System.Diagnostics.Debugger.Launch(); 
	//using集合
	// Generate using statements
    WriteUsingStatements(interfaceElement,"ImplAuto");
    WriteLine("");
    string interfaceNamespace = GetNamespace(interfaceElement.Namespace);
	 
    if(!string.IsNullOrEmpty(interfaceNamespace))
    {
#>
namespace <#= interfaceNamespace #>
{
<#
        PushIndent("\t");
    }
   
    WriteSummaryComment(interfaceElement.Description);
    WriteTemplateTypeParameterComments(TemplateParameterNameDescriptionPairs(interfaceElement));
    foreach(var comment in this.Element.GetModelStore().AllInstances<IComment>().Where(c => c.AnnotatedElements.Contains(this.Element)))
    {
        WriteRemarksComment(comment.Body);
    }
#>
<#
    WriteInterfaceClrAttributes(interfaceElement);
#>
<#
    WriteServiceContract();
#>
<#= InterfaceVisibility(interfaceElement) #><#= InterfaceUnsafeOption(interfaceElement) #><#= ImplPartialOption(interfaceElement) #>class <#= ClassifierNameForImpl(interfaceElement) #> <#= DerivationList(interfaceElement) #><# WriteClassifierConstraintOption(interfaceElement); #>
{
<#
    PushIndent("\t");
	
    foreach (IOperation operation in interfaceElement.OwnedOperations)
    {
        WriteSummaryComment(operation.Description);
        foreach (IParameter parameter in operation.OwnedParameters.Where(p => p.Direction != ParameterDirectionKind.Return))
        {
            WriteParameterComment(parameter.Name, parameter.Description);
        }

        
        WriteMethodClrAttributes(operation);
		
		WriteMethodClrAttributesForImpl(operation);		
#>
public <#= MethodUnsafeOption(operation) #><#= MethodType(operation) #> <#= operation.Name #>(<# WriteMethodParameterList(operation); #>)
<#
		//方法内容
		WriteOpertionContent(operation);
        WriteLine("");        
    } 

    PopIndent();
#>
}
<# 
    if(!string.IsNullOrEmpty(interfaceNamespace))
    {
        PopIndent();
#>
}
<#
    }
#>

<#+	
    /// <summary>
    /// Returns the visibility of the given interface
    /// </summary>
    /// <param name="anInterface">an interface</param>
    /// <returns>public, protected, protected internal, internal, or private</returns>
    private static string InterfaceVisibility(IInterface anInterface)
    {
        return Visibility(anInterface, "interface", "PackageVisibility");
    }

    /// <summary>
    /// Get list of interfaceElement's derived interfaces, formatted such that 
    /// it can be appended to an interface declaration.
    /// </summary>
    /// <param name="interfaceElement"></param>
    /// <returns>a string listing zero or more interfaces from which interfaceElement is derived.</returns>
    public static string DerivationList(IInterface interfaceElement)
    {
        string text = " : ServiceBase";
        foreach (IInterface general in InheritedInterfaces(interfaceElement))
        {
            text += ", ";
            text += ElementType(general);
        }
		var names = ClassifierProperty(element => { return GetName(element); }, GetUnboundClassifierName, AssembleName, interfaceElement);
        string name = names == null ? string.Empty : names.FirstOrDefault();		
		text +=",I"+name;
        return text;
    }

    /// <summary>
    /// Gets the list of interfaces inherited by the specified element
    /// </summary>
    /// <param name="element">the interface to query</param>
    /// <returns>list of inherited interfaces</returns>
    private static List<IInterface> InheritedInterfaces(IInterface element)
    {
        List<IInterface> inheritedInterfaces = new List<IInterface>();

        foreach (IGeneralization generalization in element.Generalizations)
        {
            IInterface general = generalization.General as IInterface;
            if (general != null)
            {
                inheritedInterfaces.Add(general);
            }
        }

        return inheritedInterfaces;
    }

    /// <summary>
    /// Writes an indexer body for interface.
    /// </summary>
    /// <param name="operation">The operation for which to generate code</param>
    private void WriteInterfaceIndexerBody(IOperation operation)
    {
        WriteLine("{ get; set; }");
    }

    /// <summary>
    /// Writes a propery definition appropriate for an interface.
    /// </summary>
    /// <param name="property">model element for which to generate code</param>
    private void WriteInterfacePropertyDeclaration(IProperty property)
    {
        Write(PropertyUnsafeOption(property));
        WritePropertyTypeAndVariableName(property, /*isEndOfLine=*/false);
        Write(" { ");
        Write(PropertyGetVisibility(property) + "get;");
        if(!property.IsReadOnly)
        {
            Write(PropertySetVisibility(property) + "set;");
        }
        WriteLine(" }");
    }
	
	private static string ImplPartialOption(IInterface element) 
    {
        return "partial ";
    }
	
	/// <summary>
	/// 返回接口需要的特性
	/// </summary>
	private void WriteServiceContract()
	{
		WriteLine("[ServiceBehavior(");
        WriteLine("//异常传播");
    	WriteLine("IncludeExceptionDetailInFaults = DebugHelper.IncludeExceptionDetailInFaults,");
        WriteLine("//事务隔离级别");
    	WriteLine("TransactionIsolationLevel = IsolationLevel.Serializable)]");
	}
	
	/// <summary>
    /// Gets the name of the classifier including the template bindings or template parameters
    /// if the classifier is a templatable classifier.
    /// </summary>
    /// <param name="classifier">The classifier</param>
    /// <returns>The name of the classifier</returns>
    private string ClassifierNameForImpl(IClassifier classifier)
    {
        var names = ClassifierProperty(element => { return GetName(element); }, GetUnboundClassifierName, AssembleName, classifier);
        string name = names == null ? string.Empty : names.FirstOrDefault();		
		
		//int nameLenth =name.Length;
		
		name =name + "Impl";
		/*
		if(nameLenth<8||name.Substring(nameLenth-7,7)!="Service")
		{
			name =name + "Service";
		}
		*/
		return name;
    }
	
	private void WriteMethodClrAttributesForImpl(IOperation operation)
	{
		//LogAttribute
		WriteLine("[LogAttribute]");
		//OperationBehavior
		string transactionType = GetTelChinaProperty(operation, "TelChinaOperation", "TransactionType");
		string transactionScopeRequired ="[OperationBehavior(TransactionScopeRequired = ";
		if(string.IsNullOrEmpty(transactionType)||transactionType=="NotSupported")
		{
			transactionScopeRequired += "false";
		}
		else
		{
			transactionScopeRequired += "true";
		}
		transactionScopeRequired +=")]";
		WriteLine(transactionScopeRequired);
	}
	/// <summary>
	/// 输出方法内容
	/// </summary>
	/// <param name="operation">操作方法</param>
	private void WriteOpertionContent(IOperation operation)
	{
		WriteLine("{");
		PushIndent("\t");
		string mothodType = MethodType(operation);
		string outPut ="base.ServiceInvoke(() => ";
		if(mothodType!="void")
		{
			outPut ="return "+ outPut;
		}
		outPut += operation.Name + "_Extend(";
		string parameterList = WriteParameterForImplList(operation,", ");
		if(!string.IsNullOrEmpty(parameterList))
		{
			outPut+= parameterList;
		}
		outPut += "));";
		WriteLine(outPut);
		PopIndent();
		WriteLine("}");
	}
	
	/// <summary>
    /// Write the parameter list for the given operation.
    /// </summary>
    /// <param name="operation">The operation</param>
    /// <param name="separator">Optional, ", " by default</param>
    private string WriteParameterForImplList(IOperation operation, string separator = ", ")
    {
        var parameters = operation.OwnedParameters.Where(p => p.Direction != ParameterDirectionKind.Return);
        int count = parameters.Count();
		string returnValue = string.Empty;
        for (int i = 0; i < count; i++)
        {
            var p = parameters.ElementAt(i);

            if (i > 0)
            {
                returnValue += separator;
            }

            returnValue += p.Name;			
        }
		return returnValue;	
    }
	
	
#>
<#+
    protected override bool AppliesToElement()
    {
         bool isTemplate = this.Element.IsTemplate;
         bool isBoundElement = this.Element.TemplateBindings != null && this.Element.TemplateBindings.Any();
         return !isTemplate && !isBoundElement && GetStereotype(this.Element) == "interface";
    }
#>
