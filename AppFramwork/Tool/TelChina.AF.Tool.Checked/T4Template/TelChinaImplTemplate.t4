<#@ Include File="TelChinaTemplateHeader.t4" #>
<#@ Modeling ElementType="Microsoft.VisualStudio.Uml.Classes.IInterface" Processor="ModelingProcessor" ApplyStereotypes="CSharp" #>
<#@ Assembly Name="Microsoft.VisualStudio.ArchitectureTools.Extensibility, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL" #>
<#@ Import Namespace="System.Linq" #>
<#@ Import Namespace="System.Text" #>
<#@ Import Namespace="Microsoft.VisualStudio.ArchitectureTools.Extensibility.Uml" #>
<#@ Import Namespace="Microsoft.VisualStudio.Uml.Classes" #>
<#@ Import Namespace="System.Collections" #>
<#@ Include File="TelChinaCSharpCommentHelpers.t4" #>
<#@ Include File="TelChinaCSharpHelpers.t4" #>
<#@ Output Extension=".cs" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
<# IInterface interfaceElement = this.Element as IInterface; #>
<# 
	//System.Diagnostics.Debugger.Launch(); 
	//using集合
	// Generate using statements
    WriteUsingStatements(interfaceElement,"Impl");
    WriteLine("");
    string interfaceNamespace = GetNamespace(interfaceElement.Namespace);
	 
    if(!string.IsNullOrEmpty(interfaceNamespace))
    {
#>
namespace <#= interfaceNamespace #>
{
<#
        PushIndent("\t");
    }
   
    WriteSummaryComment(interfaceElement.Description);
    WriteTemplateTypeParameterComments(TemplateParameterNameDescriptionPairs(interfaceElement));
    foreach(var comment in this.Element.GetModelStore().AllInstances<IComment>().Where(c => c.AnnotatedElements.Contains(this.Element)))
    {
        WriteRemarksComment(comment.Body);
    }
#>
<#
    WriteInterfaceClrAttributes(interfaceElement);
#>
<#= InterfaceVisibility(interfaceElement) #><#= InterfaceUnsafeOption(interfaceElement) #><#= ImplPartialOption(interfaceElement) #>class <#= ClassifierNameForImpl(interfaceElement) #> 
{
<#
    PushIndent("\t");
	
    foreach (IOperation operation in interfaceElement.OwnedOperations)
    {
        WriteSummaryComment(operation.Description);
        foreach (IParameter parameter in operation.OwnedParameters.Where(p => p.Direction != ParameterDirectionKind.Return))
        {
            WriteParameterComment(parameter.Name, parameter.Description);
        }

        
        WriteMethodClrAttributes(operation);
#>
private <#= MethodUnsafeOption(operation) #><#= MethodType(operation) #> <#= operation.Name #>_Extend(<# WriteMethodParameterList(operation); #>)
<#
		//方法内容
		WriteOpertionContent(operation);
        WriteLine("");
    } 

    PopIndent();
#>
}
<# 
    if(!string.IsNullOrEmpty(interfaceNamespace))
    {
        PopIndent();
#>
}
<#
    }
#>

<#+	
    /// <summary>
    /// Returns the visibility of the given interface
    /// </summary>
    /// <param name="anInterface">an interface</param>
    /// <returns>public, protected, protected internal, internal, or private</returns>
    private static string InterfaceVisibility(IInterface anInterface)
    {
        return Visibility(anInterface, "interface", "PackageVisibility");
    }

    /// <summary>
    /// Get list of interfaceElement's derived interfaces, formatted such that 
    /// it can be appended to an interface declaration.
    /// </summary>
    /// <param name="interfaceElement"></param>
    /// <returns>a string listing zero or more interfaces from which interfaceElement is derived.</returns>
    public static string DerivationList(IInterface interfaceElement)
    {
        string text = string.Empty;

        int count = 0;
        foreach (IInterface general in InheritedInterfaces(interfaceElement))
        {
            text += (count++ == 0) ? " : " : ", ";
            text += ElementType(general);
        }
        return text;
    }

    /// <summary>
    /// Gets the list of interfaces inherited by the specified element
    /// </summary>
    /// <param name="element">the interface to query</param>
    /// <returns>list of inherited interfaces</returns>
    private static List<IInterface> InheritedInterfaces(IInterface element)
    {
        List<IInterface> inheritedInterfaces = new List<IInterface>();

        foreach (IGeneralization generalization in element.Generalizations)
        {
            IInterface general = generalization.General as IInterface;
            if (general != null)
            {
                inheritedInterfaces.Add(general);
            }
        }

        return inheritedInterfaces;
    }

    /// <summary>
    /// Writes an indexer body for interface.
    /// </summary>
    /// <param name="operation">The operation for which to generate code</param>
    private void WriteInterfaceIndexerBody(IOperation operation)
    {
        WriteLine("{ get; set; }");
    }

    /// <summary>
    /// Writes a propery definition appropriate for an interface.
    /// </summary>
    /// <param name="property">model element for which to generate code</param>
    private void WriteInterfacePropertyDeclaration(IProperty property)
    {
        Write(PropertyUnsafeOption(property));
        WritePropertyTypeAndVariableName(property, /*isEndOfLine=*/false);
        Write(" { ");
        Write(PropertyGetVisibility(property) + "get;");
        if(!property.IsReadOnly)
        {
            Write(PropertySetVisibility(property) + "set;");
        }
        WriteLine(" }");
    }
	
	private static string ImplPartialOption(IInterface element) 
    {
        return "partial ";
    }	
	
	/// <summary>
    /// Gets the name of the classifier including the template bindings or template parameters
    /// if the classifier is a templatable classifier.
    /// </summary>
    /// <param name="classifier">The classifier</param>
    /// <returns>The name of the classifier</returns>
    private string ClassifierNameForImpl(IClassifier classifier)
    {
        var names = ClassifierProperty(element => { return GetName(element); }, GetUnboundClassifierName, AssembleName, classifier);
        string name = names == null ? string.Empty : names.FirstOrDefault();		
		/*
		int nameLenth =name.Length;
		if(nameLenth<8||name.Substring(nameLenth-7,7)!="Service")
		{
			name =name + "Service";
		}
		*/
		name =name + "Impl";
		return name;
    }
	
	/// <summary>
	/// 输出方法内容
	/// </summary>
	/// <param name="operation">操作方法</param>
	private void WriteOpertionContent(IOperation operation)
	{
		WriteLine("{");
		PushIndent("\t");		
		WriteLine(" throw new NotImplementedException();");
		PopIndent();
		WriteLine("}");
	}
	
#>
<#+
    protected override bool AppliesToElement()
    {
         bool isTemplate = this.Element.IsTemplate;
         bool isBoundElement = this.Element.TemplateBindings != null && this.Element.TemplateBindings.Any();
         return !isTemplate && !isBoundElement && GetStereotype(this.Element) == "interface";
    }
#>
