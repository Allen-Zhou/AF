<#@ Include File="TelChinaTemplateHeader.t4" #>
<#@ Modeling ElementType="Microsoft.VisualStudio.Uml.Classes.IInterface" Processor="ModelingProcessor" ApplyStereotypes="CSharp" #>
<#@ Assembly Name="Microsoft.VisualStudio.ArchitectureTools.Extensibility, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL" #>
<#@ Import Namespace="System.Linq" #>
<#@ Import Namespace="System.Text" #>
<#@ Import Namespace="Microsoft.VisualStudio.ArchitectureTools.Extensibility.Uml" #>
<#@ Import Namespace="Microsoft.VisualStudio.Uml.Classes" #>
<#@ Import Namespace="System.Collections" #>
<#@ Include File="TelChinaCSharpCommentHelpers.t4" #>
<#@ Include File="TelChinaCSharpHelpers.t4" #>
<#@ Output Extension=".cs" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
<# IInterface interfaceElement = this.Element as IInterface; #>
<# 
	//System.Diagnostics.Debugger.Launch(); 
	//using集合
	// Generate using statements
    WriteUsingStatements(interfaceElement,"Contract");
    WriteLine("");
    string interfaceNamespace = GetNamespace(interfaceElement.Namespace);
	 
    if(!string.IsNullOrEmpty(interfaceNamespace))
    {
#>
namespace <#= interfaceNamespace #>
{
<#
        PushIndent("\t");
    }
   
    WriteSummaryComment(interfaceElement.Description);
    WriteTemplateTypeParameterComments(TemplateParameterNameDescriptionPairs(interfaceElement));
    foreach(var comment in this.Element.GetModelStore().AllInstances<IComment>().Where(c => c.AnnotatedElements.Contains(this.Element)))
    {
        WriteRemarksComment(comment.Body);
    }
#>
<#
    WriteInterfaceClrAttributes(interfaceElement);
#>
<#
    WriteServiceContract();
#>
<#= InterfaceVisibility(interfaceElement) #><#= InterfaceUnsafeOption(interfaceElement) #><#= InterfacePartialOption(interfaceElement) #>interface <#= ClassifierNameForContract(interfaceElement) #> <#= DerivationList(interfaceElement) #><# WriteClassifierConstraintOption(interfaceElement); #>
{
<#
    PushIndent("\t");
	//是否存在同名
	Hashtable opertionExist = new Hashtable();
	foreach (IOperation operation in interfaceElement.OwnedOperations)
    {
		if(!opertionExist.ContainsKey(operation.Name))
		{
			opertionExist.Add(operation.Name,0);
		}
		else
		{
			
			int existtimes = int.Parse(opertionExist[operation.Name].ToString())+1;
			opertionExist.Remove(operation.Name);
			opertionExist.Add(operation.Name,existtimes);
		}
	}
    foreach (IOperation operation in interfaceElement.OwnedOperations)
    {
        WriteSummaryComment(operation.Description);
        foreach (IParameter parameter in operation.OwnedParameters.Where(p => p.Direction != ParameterDirectionKind.Return))
        {
            WriteParameterComment(parameter.Name, parameter.Description);
        }

        if(GetStereotype(operation) == "method")
        {
            WriteMethodClrAttributes(operation);
			int IsExist = int.Parse(opertionExist[operation.Name].ToString());
			bool exist = false;
			if(IsExist>0)
			{
				exist =true;
			}
			WriteMethodClrAttributesForContract(operation,exist);
#>
<#= MethodUnsafeOption(operation) #><#= MethodType(operation) #> <#= operation.Name #>(<# WriteMethodParameterList(operation); #>);
<#
            WriteLine("");
        }
        else if(GetStereotype(operation) == "indexer") 
        {
            WriteIndexerClrAttributes(operation);
#>
<#= IndexerUnsafeOption(operation) #><#= IndexerType(operation) #> this[<# WriteIndexerParameterList(operation); #>] <# WriteInterfaceIndexerBody(operation); #>
<#
			WriteLine("");
        }
    } 

    PopIndent();
#>
}
<# 
    if(!string.IsNullOrEmpty(interfaceNamespace))
    {
        PopIndent();
#>
}
<#
    }
#>

<#+
	Hashtable opertionNames = new Hashtable();
    /// <summary>
    /// Returns the visibility of the given interface
    /// </summary>
    /// <param name="anInterface">an interface</param>
    /// <returns>public, protected, protected internal, internal, or private</returns>
    private static string InterfaceVisibility(IInterface anInterface)
    {
        return Visibility(anInterface, "interface", "PackageVisibility");
    }

    /// <summary>
    /// Get list of interfaceElement's derived interfaces, formatted such that 
    /// it can be appended to an interface declaration.
    /// </summary>
    /// <param name="interfaceElement"></param>
    /// <returns>a string listing zero or more interfaces from which interfaceElement is derived.</returns>
    public static string DerivationList(IInterface interfaceElement)
    {
        string text = string.Empty;

        int count = 0;
        foreach (IInterface general in InheritedInterfaces(interfaceElement))
        {
            text += (count++ == 0) ? " : " : ", ";
            text += ElementType(general);
        }

        return text;
    }

    /// <summary>
    /// Gets the list of interfaces inherited by the specified element
    /// </summary>
    /// <param name="element">the interface to query</param>
    /// <returns>list of inherited interfaces</returns>
    private static List<IInterface> InheritedInterfaces(IInterface element)
    {
        List<IInterface> inheritedInterfaces = new List<IInterface>();

        foreach (IGeneralization generalization in element.Generalizations)
        {
            IInterface general = generalization.General as IInterface;
            if (general != null)
            {
                inheritedInterfaces.Add(general);
            }
        }

        return inheritedInterfaces;
    }

    /// <summary>
    /// Writes an indexer body for interface.
    /// </summary>
    /// <param name="operation">The operation for which to generate code</param>
    private void WriteInterfaceIndexerBody(IOperation operation)
    {
        WriteLine("{ get; set; }");
    }

    /// <summary>
    /// Writes a propery definition appropriate for an interface.
    /// </summary>
    /// <param name="property">model element for which to generate code</param>
    private void WriteInterfacePropertyDeclaration(IProperty property)
    {
        Write(PropertyUnsafeOption(property));
        WritePropertyTypeAndVariableName(property, /*isEndOfLine=*/false);
        Write(" { ");
        Write(PropertyGetVisibility(property) + "get;");
        if(!property.IsReadOnly)
        {
            Write(PropertySetVisibility(property) + "set;");
        }
        WriteLine(" }");
    }
	/// <summary>
	/// 返回接口需要的特性
	/// </summary>
	private void WriteServiceContract()
	{
		WriteLine("[ServiceContract]");
    	WriteLine("[PolicyInjectionBehavior] //提供PIAB接口");
	}
	
	/// <summary>
    /// Gets the name of the classifier including the template bindings or template parameters
    /// if the classifier is a templatable classifier.
    /// </summary>
    /// <param name="classifier">The classifier</param>
    /// <returns>The name of the classifier</returns>
    private string ClassifierNameForContract(IClassifier classifier)
    {
        var names = ClassifierProperty(element => { return GetName(element); }, GetUnboundClassifierName, AssembleName, classifier);
        string name = names == null ? string.Empty : names.FirstOrDefault();
		/*
		if(name.Substring(0,1)!="I")
		{
			name ="I"+name;
		}
		
		int nameLenth =name.Length;
		if(nameLenth<8||name.Substring(nameLenth-7,7)!="Service")
		{
			name =name + "Service";
		}
		*/
		name ="I"+name;
		return name;
    }
	
	private void WriteMethodClrAttributesForContract(IOperation operation,bool isExist)
	{
		//operationContract
		string operationContract ="[OperationContract";
		if(!opertionNames.ContainsKey(operation.Name))
		{
			opertionNames.Add(operation.Name,0);
			if(isExist)
			{
				operationContract +="(Name = \""+ operation.Name +"\")";
			}
			operationContract +="]";
		}
		else
		{			
			int opertiontimes = int.Parse(opertionNames[operation.Name].ToString())+1;
			opertionNames.Remove(operation.Name);
			opertionNames.Add(operation.Name,opertiontimes);
			operationContract +="(Name = \""+ operation.Name + opertiontimes.ToString() +"\")]";			
		}
		WriteLine(operationContract);
		WriteLine("//允许接收来自客户端事务流");
		WriteLine("//如果客户端传入了事务,则沿用,否则新建事务");
		//TransactionFlowOption
		string transactionType = GetTelChinaProperty(operation, "TelChinaOperation", "TransactionType");
		string transactionFlowOption ="[TransactionFlow(TransactionFlowOption.";//Allowed)]"
		if(string.IsNullOrEmpty(transactionType)||transactionType=="Required")
		{
			transactionFlowOption += "Allowed";
		}
		else
		{
			transactionFlowOption += "NotAllowed";
		}
		transactionFlowOption +=")]";
		WriteLine(transactionFlowOption);
	}
#>
<#+
    protected override bool AppliesToElement()
    {
         bool isTemplate = this.Element.IsTemplate;
         bool isBoundElement = this.Element.TemplateBindings != null && this.Element.TemplateBindings.Any();
         return !isTemplate && !isBoundElement && GetStereotype(this.Element) == "interface";
    }
#>
